#!/usr/bin/env python
# **********************************************************************
#
# dep - dependency
# rive - to tear apart, tear into pieces
#
##COPYRIGHT
# Copyright (C) 2012, Lars J. Aas <lars.j.aas@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
##
#
##VERSION
# deprive v0.6
##
#
##USAGE
# Usage: deprive [options]...
#   -h | -? | --help
#   -v | --verbose
#   --copyright
#   --usage
#   --examples
#   --version
#   --analyze
#   --database <pyfile>
#   --merge
#   --stdin
#   --trace <object>
#   --format=<list|tree|python>
#   --list --tree --python
#   --levels=<N>
#   --prefix=<prefix>
#-
#-  --output=<python|dot|list|make|scons>
#-  --group=<object|directory>
#-  --input=<objects|python>
#-  --stat
#-  --regex=<>
#-
##
#
##HELP
# Deprive is a utility for analyzing object file link dependencies.
# It can be useful when you work on cleaning up and refactoring legacy
# codebases with a lot of spaghetti code.
#
# Run 'deprive --usage' for information about command options.
##
#
##EXAMPLES
# Analyze object dependencies and store them in 'deps.py':
#   $ deprive --database deps.py --analyze */*.o
#
# Use --stdin if the file list might be too long even for xargs:
#   $ find build/ -name "*.o" | deprive --database deps.py --stdin --analyze
#
##
#
# Author:
#   Lars J. Aas <lars.j.aas@gmail.com>
#
##TODO
# - make config part of calls or make classes with config member
# - store symbols data to be able to avoid object file scan when debugging
#   reference building
##
# **********************************************************************

import sys, os, platform, commands, imp, string

# if sys.version_info[:2] <= (2, 6):
#     sys.stderr.write('error: deprive requires python 2.X or later\n')
#     exit(1)

control = {}
prefix = ''
entry = '%ENTRY%'

def GetConfig(program):
    config = {
        'program': program,
        'system': platform.system().lower(),
        'defined': '',
        'undefined': '',
    }

    # TODO: for cygwin/windows, add objdump or dumpbin support
    if config['system'] == 'darwin':
        config['defs'] = 'nm -gjU {0}'
        config['refs'] = 'nm -gju {0}'

    elif config['system'] == 'linux':
        config['defs'] = 'nm -g --defined-only {0} | cut -c20-'
        config['refs'] = 'nm -g --undefined-only {0} | cut -c20-'

    else:
        print config['program'] + ': error: do not know this system.'
        exit(-1)

    return config

def PrintHereDocument(filename, block):
    file = open(filename)
    inblock = False
    while 1:
        line = file.readline().strip()
        if not line:
            break
        if inblock:
            if line == '##':
                break
            elif line.startswith('#-'):
                pass
            else:
                print line[2:]
        else:
            if line == '##' + block.upper():
                inblock = True
    file.close()

# **************************************************************************
# Dependencies

class Dependencies(object):
    def __init__(self):
        self.dependencies = {}
        self.funcname = 'getDependencies'

    def analyze(self, config, paths):
        sym2obj = {}
        deps = self.dependencies
        for path in paths:
            if not os.path.exists(path) or os.path.isdir(path):
                sys.stderr.write('warning: no file "{0}".'.format(path))
                paths.remove(path)

        maxindex = len(paths)
        index = 0
        for file in paths:
            handle = file
            if file.startswith(config['prefix']):
                handle = file[len(config['prefix']):]

            index = index + 1
            if config['verbose']:
                sys.stdout.write('Finding exports for {0} ({1}/{2}).\n'.\
                                 format(handle, index, maxindex))
            command = config['defs'].format(file)
            for symbol in commands.getoutput(command).split('\n'):
                sym2obj[symbol] = handle

        # my god, this part is slow...
        index = 0
        for file in paths:
            handle = file
            if file.startswith(config['prefix']):
                handle = file[len(config['prefix']):]

            index = index + 1
            if config['verbose']:
                sys.stdout.write('Analyzing imports for {0} ({1}/{2}).\n'.\
                                 format(handle, index, maxindex))
            command = config['refs'].format(file)
            for symbol in commands.getoutput(command).split('\n'):
                if symbol in sym2obj:
                    if handle in deps:
                        if not sym2obj[symbol] in deps[handle]:
                            deps[handle].append(sym2obj[symbol])
                    else:
                        deps[handle] = [ sym2obj[symbol] ]
                # else: undefined reference could go to lib

        self.dependencies = deps

    def load(self, filename):
        module = imp.new_module('database')
        module.__file__ = filename
        execfile(filename, module.__dict__)
        if self.funcname in module.__dict__:
            self.dependencies = module.getDependencies()
        else:
            print 'error: {0} not a dependency database.'.format(filename)

    def save(self, filename):
        if filename == '-':
            self.output(self.dependencies)
        else:
            f = open(filename, 'w')
            self.output(self.dependencies, f)
            f.close()

    def output(self, deps, stream = sys.stdout):
        stream.write('def {0}():\n'.format(self.funcname))
        stream.write('    deps = {\n')
        for key in sorted(deps.keys()):
            if key == entry:
                continue
            stream.write('        \'{0}\': [\n'.format(key))
            for value in sorted(deps[key]):
                stream.write('            \'{0}\',\n'.format(value))
            stream.write('        ],\n')
        stream.write('    }\n')
        stream.write('    return deps\n')

    def get(self):
        return self.dependencies

    def trace(self, source, levels = False):
        found = False
        for key in self.dependencies:
            if key.endswith(source):
                found = key
        if not found:
            print 'key {0} not found.'.format(source)
            return

        deps = {
                entry: [ found, ],
        }
        if not levels:
            deps[found] = self.dependencies[found]
            incoming = deps[found]
            i = 0
            while i < len(incoming):
                obj = incoming[i]
                if not obj in deps:
                    if obj in self.dependencies:
                        deps[obj] = self.dependencies[obj]
                        for item in deps[obj]:
                            if item not in incoming:
                                incoming.append(item)
                    else:
                        deps[obj] = []
                i = i + 1

        else:
            deps[found] = self.dependencies[found]
            thislevel = deps[found]
            nextlevel = []
            exit(1)
            # FIXME: implement looping level by level
            #while levels > 1:
            #    levels -= 1
            #    for key in incoming:
            #        if not key in deps:

        return deps

# **********************************************************************

def ListOutput(dependencies, array, current, stream = sys.stdout):
    if current != entry:
        array.append(current)

    if current in dependencies:
        for dependency in dependencies[current]:
            if dependency not in array:
                ListOutput(dependencies, array, dependency)

    if current == entry:
        for item in sorted(array):
            stream.write(item + '\n')

def TreeOutput(dependencies, stack, current, \
               indent = '', stream = sys.stdout, flags = [False]):

    if len(flags) > 1 and flags[len(flags)-2]:
        i = len(indent) - 4
        if indent[i] == '|':
          indent = indent[0:i] + ' ' + indent[i+1:]

    if current in stack:
        stream.write(indent + ' [' + current + ']\n')
        return

    newstack = stack + [ current ]
    if indent == '':
        stream.write('.' + current + '\n')
    else:
        stream.write(indent + ' ' + current + '\n')
    newindent = indent.translate(string.maketrans('-+', ' |')) + '+-'
    if current in dependencies:
        for dependency in dependencies[current]:
            flag = False
            if dependency == dependencies[current][len(dependencies[current])-1]:
                flag = True
            newflags = flags + [ flag ]
            TreeOutput(dependencies, newstack, dependency,
                       indent=newindent,
                       stream=stream,
                       flags=newflags)

# **********************************************************************

def main():
    config = GetConfig(sys.argv[0])

    longopts = {
        '-?': '--help',
        '-h': '--help',
        '-v': '--verbose',
    }

    aliases = {
        '--tree': '--format=tree',
        '--list': '--format=list',
        '--python': '--format=python',
    }

    heredocs = [
        '--version',
        '--copyright',
        '--usage',
        '--help',
        '--examples',
    ]

    restargs = []
    usestdin = False
    format = 'python'

    config['database'] = ''
    config['verbose'] = False

    control['mode'] = 'nop'
    control['args'] = 'cmdline'

    control['load'] = False
    control['analyze'] = False
    control['save'] = False
    control['trace'] = False
    control['output'] = False

    control['stdin'] = False
    next = 'program'
    for opt in sys.argv:
        if next != '':
            if next == 'restargs':
                restargs += [ opt ]
                continue

            elif next == 'database':
                config['database'] = opt

            elif next == 'trace':
                control['trace'] = opt

            elif next == 'program':
                config['programpath'] = opt

            next = ''
            continue

        if opt.startswith('-'):
            if opt.startswith('--'):
                pass

            elif opt in longopts:
                opt = longopts[opt]

            else:
                print 'error: unknown option "' + opt + '".\n'
                exit(1)

        if opt.startswith('--'):
            if opt in aliases:
                opt = aliases[opt]

            if opt in heredocs:
                PrintHereDocument(config['program'], opt[2:])
                exit(0)

            elif opt == '--':
                next = 'restargs'

            elif opt == '--database':
                next = 'database'

            elif opt == '--trace':
                next = 'trace'

            elif opt == '--verbose':
                config['verbose'] = True

            elif opt == '--analyze':
                control['mode'] = 'analyze'
                control['analyze'] = True
                control['save'] = True

            elif opt == '--stdin':
                control['stdin'] = True

            elif opt == '--merge':
                control['load'] = True

            elif opt.startswith('--format='):
                outputformat = opt.split('=', 1)[1]
                if outputformat in ['list', 'tree', 'python', 'digraph']:
                    control['output'] = outputformat
                else:
                    print 'error: unknown format "{0}" for --output.\n'
                    exit(1)

            elif opt.startswith('--prefix='):
                config['prefix'] = opt.split('=', 1)[1]

            else:
                print 'error: unknown long-option "' + opt + '".\n'
                exit(1)

        else:
            restargs += [ opt ]

    if not control['analyze']:
        control['load'] = True

# **************************************************************************

    dependencies = Dependencies()

    if control['stdin']:
        if config['verbose']:
            print 'Reading from stdin.'

        restargs = sys.stdin.readlines()
        i = 0
        count = len(restargs)
        while i < count:
            restargs[i] = restargs[i].strip()
            i += 1

        if config['verbose']:
            print 'Got {0} objects.'.format(len(restargs))

    # database update first
    if control['load']:
        if config['database'] != '':
            dependencies.load(config['database'])

    if control['analyze']:
        if config['database'] != '':
            dependencies.analyze(config, restargs)
            restargs = []

    if control['save']:
        if config['database'] != '':
            dependencies.save(config['database'])

    deps = {}
    if control['trace']:
        deps = dependencies.trace(control['trace'])

    if control['output']:
        if control['output'] == 'list':
            ListOutput(deps, [], entry)

        if control['output'] == 'tree':
            TreeOutput(deps, [], deps[entry][0])

        if control['output'] == 'python':
            dependencies.output(deps)

        if control['output'] == 'digraph':
            pass

if __name__ == '__main__':
    main()

# vim: ft=python:shiftwidth=4
