<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Deprive by larsjaas</title>

<link rel="stylesheet" href="stylesheets/styles.css">
<link rel="stylesheet" href="stylesheets/pygment_trac.css">
<script src="javascripts/scale.fix.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
</head>
<body>
<div class="wrapper">
<header>
<h1>Deprive</h1>
<p>Object File and Library Link Dependency Analysis</p>
<p class="view"><a href="https://github.com/larsjaas/deprive">View the Project on GitHub <small>larsjaas/deprive</small></a></p>
<ul>
<li><a href="https://github.com/larsjaas/deprive/zipball/master">Download <strong>ZIP File</strong></a></li>
<li><a href="https://github.com/larsjaas/deprive/tarball/master">Download <strong>TAR Ball</strong></a></li>
<li><a href="https://github.com/larsjaas/deprive">View On <strong>GitHub</strong></a></li>
</ul>
</header>
<section>

<h3>About</h3>
<p>
<strong>Deprive</strong> is a command line utility for doing object file and
library link-time interdependency analysis.  The primary audience for deprive
is software engineers involved in development on large-scale <code>C/C++</code>
(and similar languages) software projects.
</p>
<p>
Why should you care about link-time dependencies?  Have you heard about 10
second builds?  When you don't work on the 10-second compile-link-run cycle,
you constantly break out of your programming zone, and your productivity
drops down like you wouldn't believe.  More than 10 seconds of wait time
before you get your feedback, and you will find that your second monitor is
mostly filled throughout the day with Reddit and Hacker News.
</p>
<p>
To achieve 10 second builds, you need to be in total control of the link-time
dependencies in a large software project.  It will influence your architectural
designs down to the core.  To get there, you need tools like deprive, to tell
you exactly what you are pulling in of dependencies when you only want to work
on some miniscule piece of the total system.
</p>
<p>
Once you see the dependencies, you can start detangling them, decoupling them,
destroying them, depriving them... But that is a topic for another web page.
</p>

<h3>Basic Usage</h3>
<p>
Given (hypothetically) a project that builds all object files under src/ and
lib/, and has a source file defining main() named ls.c (for this hypothetical
example I have been using fileutils-4.1), you can show the dependency graph for
the program of interest like this:
</p>
<pre><code>$ deprive --scan --analyze lib/*.o src/*.o
$ deprive --trace ls.o --digraph | dot -Tpng - >ls.png
</code></pre>
<p>
The above commands will produce the below ls.png image.  Follow the image link
to get the full size image.
</p>
<p>
<a href="images/ls.png"><img src="images/ls600.png"/></a>
</p>
<p>
From this image you can see that ls.o references argmatch.o, while argmatch.o
also references ls.o back, so you have a circular reference.  Inspecting the
object files, you will find out that ls.o defines the function "usage", which
argmatch.o references for some reason.  There is also a circular reference from
ls.o via human.o to argmatch.o in the graph - the circularity comes from the
exact same reason as the first circular dependency mentioned.
</p>
<p>
Beyond detecting circular dependencies, you will also be able to get a decent
overview of the program architecture and flow by looking at the dependency
graphs.  If you are trying to get an understanding of the architecture of a
new codebase, having the dependencies visualized in this way can be very
beneficial.  Also, if you want to refactor something in a large project,
looking at dependency graphs can give you an idea of how much work it will be
to do the wanted refactoring.
</p>

<h3>Advanced Usage</h3>
<p>
Not all programs are as simple as GNU ls to analyze.  For really large-scale
projects, it is natural to use a more flexible, dynamic approach for listing
the object files:
</p>
<pre><code>$ <font color="yellow">find ./build -name "*.o" | xargs</font> deprive --scan --analyze
$ deprive --trace main.o --digraph | dot -Tpng - >program.png
</code></pre>
<p>
Now, in the above example, xargs is used to pile the object filenames on the
deprive command line.  But even xargs has its limits.  When xargs gets too many
arguments on stdin, it will split the arguments into groups and do multiple
invokations of the program it invokes.  This is not supported, so in this case
you need to let deprive read the file list from stdin instead.
</p>
<pre><code>$ find ./build -name "*.o" | deprive <font color="yellow">--stdin</font> --scan --analyze
$ deprive --trace main.o --digraph | dot -Tpng - >program.png
</code></pre>
<p>
Now you can begin analyzing really large projects.  The problem now is - the
graphical images of the object file dependencies will get way too large.
This is why I recommend using the dependency graphs mostly on unittest programs,
and not for full systems.  For full system analysis, I will implement
directory-based grouping of object files, but in the mean time you can simply
link subdirectories to libraries, and instead of scanning object files
do the scan on the library files instead.
</p>

<h3>Other Usage</h3>
<p>
The dependency database is a python dict, and can as such be trivially loaded
directly into Python scripts.  There are some interesting possibilities opened
up by this fact.  You can for instance use the dependency tree in your
<strong>SCons</strong> SConstruct files to automatically link up minimal
unittest programs.  You will not need to maintain the source file list for each
unittest program manually, as long as all the object files needed are compiled
regularly, and the dependency database is updated when needed afterwards.
This is not totally trivial to do, but I will include some sample code for doing
it as soon as I get around to it...
</p>

<h3>A Note About Link-Time Dependencies</h3>
<p>
The view you get with deprive is only of link-time dependencies.  There are also
compile-time dependencies which are completely resolved at compile-time.  You do
not see any trace of those at link-time.  Inline functions is one such dependency
that is resolved at compile-time.  Template classes are for instance often all
inline.  Referencing of enum values in headers for other compile units is another
dependency you don't see at link-time...
</p>
<p>
This means that you do not always get the full picture of the code dependencies
when you use deprive.  That doesn't mean that using deprive won't be useful
though, regardless of that "deficiency".  It is just one of those things you
need to be aware of when using deprive...
</p>

<h3>Deprive Dependencies</h3>
<p>
Deprive is implemented in <strong>Python</strong>.  To scan object files, deprive
uses external commands.  Currently only <strong>nm</strong> is supported.  The nm
program is part of the binutils package (iirc).  If you are a software developer,
both Python and nm should aready be installed on your system.
</p>
<p>
To view the dependency graphs graphically you will need <strong>GraphViz</strong>
(or <strong>dot</strong>, more specifically) to render the graph descriptions.
You will also need an image viewer, of course.
</p>

<h3>Platforms</h3>
<p>
Deprive works on <strong>Linux</strong> and <strong>Mac OS X</strong>.
Porting to new platforms is just a matter of setting up the symbol-listing
commands, so if your platform is missing, it should be relatively easy to
add it.  Search for 'linux' and 'darwin' in the deprive script file...
</p>
<p>
A Windows MSVC port is something I plan to do in the future, but it is not
a priority right now.
</p>

</section>
</div>
<footer>
<p>Project maintained by <a href="http://larsjaas.github.com/">larsjaas</a></p>
<p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
</footer>
<!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
</body>
</html>
